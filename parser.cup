/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java.util.*;
import java_cup.runtime.*;
import ir.ast.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:

  public boolean syntaxErrors;

  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("fuente.ctds");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal 			CLASS,RETURN,EXTERN,VOID,COMA,PUNTO,PUNTOYCOMA;
/*Terminales estructuras de control*/
terminal 			BREAK,CONTINUE,ELSE,FOR,IF,WHILE;
/*Terminales llaves,parentesis y corchetes*/
terminal 			LLAVE_IZQUIERDA,LLAVE_DERECHA,PARENTESIS_IZQUIERDO,PARENTESIS_DERECHO,CORCHETE_IZQUIERDO,CORCHETE_DERECHO;
/*Terminales operaciones aritmeticas*/
terminal 			SUMA,RESTA,MULTIPLICACION,DIVISION,PORCENTAJE;
/*Terminales operaciones asignacion*/
terminal 			ASIGNACION,ASIGNACION_SUMA,ASIGNACION_RESTA;
/*Terminales operaciones comparacion*/
terminal 			MENOR,MAYOR,MENOR_IGUAL,MAYOR_IGUAL,IGUAL,DESIGUAL;
/*Terminales operaciones logicas*/
terminal 			NEGACION, CONJUNCION,DISYUNCION;
/*Terminales tipos*/
terminal 			INT, FLOAT, BOOLEAN;
terminal Integer	INTEGER_LITERAL;        // our scanner provides numbers as integers
terminal Float 		FLOAT_LITERAL;
terminal Boolean	FALSE_LITERAL;
terminal Boolean	TRUE_LITERAL;
terminal String 	ID;

/* Non terminals */
non terminal Program 					program;

non terminal List<ClassDeclaration>		class_decl_list;
non terminal ClassDeclaration       	class_decl;

non terminal List<FieldDeclaration>		field_decl_list;
non terminal FieldDeclaration			field_decl;
non terminal List<Expr.Identifier>  	ident_list;
non terminal 							id_list;
non terminal List<MethodDeclaration>	method_decl_list;
non terminal MethodDeclaration			method_decl;
non terminal 						  	method_list;

non terminal Body						body;
non terminal Block						block;
non terminal Type						type;
non terminal List<Statement>			statement_list;
non terminal Statement					statement;
non terminal AssignOpType				assign_op;
non terminal MethodCallStmt				method_call;
non terminal Location					location;
non terminal Expression					expr;      // used to store evaluated subexpressions
non terminal BinOpType					bin_op;
non terminal BinOpType					arith_op;
non terminal BinOpType					rel_op;
non terminal BinOpType					eq_op;
non terminal BinOpType					cond_op;
non terminal Literal					literal;
non terminal List<Expression>			expr_list;

/* Precedences */
precedence right ASIGNACION, ASIGNACION_RESTA, ASIGNACION_SUMA;
precedence left LLAVE_IZQUIERDA, LLAVE_DERECHA, PARENTESIS_IZQUIERDO, PARENTESIS_DERECHO, CORCHETE_IZQUIERDO, CORCHETE_DERECHO;
precedence left SUMA, RESTA, MULTIPLICACION, DIVISION, PORCENTAJE;
precedence left NEGACION, MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL, IGUAL, DESIGUAL;
precedence left CONJUNCION, DISYUNCION;

/* The grammar rules */
program ::= class_decl_list:cdl {: RESULT = new Program(cdl); :} ;
/* declaracion de clase/s */

class_decl_list	::= class_decl:c class_decl_list:cdl {: cdl.add(c); RESULT = cdl; :} /*chequeo de clase existente y clase main */
				| /* empty */  {: RESULT = new LinkedList<ClassDeclaration>(); :};

class_decl ::= CLASS ID:c LLAVE_IZQUIERDA:lli field_decl_list:fdl method_decl_list:mdl LLAVE_DERECHA:lld {: RESULT = new ClassDeclaration(c,fdl,mdl); :} ;

/* declaracion de campos y metodos */
field_decl_list		::= field_decl:fd field_decl_list:fld {: fdl.add(fd); RESULT = fdl; :}
					|/* empty  */  {: RESULT = new LinkedList<FieldDeclaration>(); :};

field_decl 	::= type:t ID:f ident_list:idl PUNTOYCOMA:pc {: RESULT = new FieldDeclaration(t,f,idl); :}
			| type:t ID:f CORCHETE_IZQUIERDO:ci INTEGER_LITERAL:il CORCHETE_DERECHO:cd ident_list:idl PUNTOYCOMA:pc {: RESULT = new FieldDeclaration(t,il,f,idl); :};
            
ident_list  ::= ident_list:idl COMA:c ID:f 	{: idl.add(new Identifier(f)); RESULT = idl; :}
    		| /* empty  */	{: RESULT = new LinkedList<Identifier>(); :};

method_decl_list	::= method_decl:md method_decl_list:mdl {: fdl.add(md); RESULT = mdl; :}
					| /* empty  */  {: RESULT = new LinkedList<MethodDeclaration>(); :};

method_decl ::= type:t ID:m PARENTESIS_IZQUIERDO:pi field_decl_list:fdl PARENTESIS_DERECHO:pd body:b {: RESULT = new MethodDeclaration(t,m,fdl,b); :} /*preguntar por esta clase*/
			| VOID:v ID:m PARENTESIS_IZQUIERDO:pi field_decl_list:fdl PARENTESIS_DERECHO:pd body:b {: RESULT = new MethodDeclaration(Type.VOID,m,fdl,b); :};

body 	::= EXTERN:e PUNTOYCOMA:pc {: RESULT = new Body(true,e); :} /*Aca deberia importar el codigo desde e?*/
		| block:b {: RESULT = new Body(b):};

block	::= LLAVE_IZQUIERDA:lli field_decl_list:fdl statement_list:sl LLAVE_DERECHA:lld {: RESULT = new Block(sl); :};


statement_list	::= statement_list:sl statement:s  {: sl.add(s); RESULT = sl; :}
				| /* empty  */  {: RESULT = new LinkedList<Statement>(); :};

type 	::= INT:i {: RESULT = Type.INT; :}
		| FLOAT:f {: RESULT = Type.INT; :}
		| BOOLEAN:b {: RESULT = Type.INT; :};


//////////////////////////////////////////////////
// HASTA ACA LLEGUE HOY FALTA DE ACA PARA ABAJO //
//////////////////////////////////////////////////

statement 	::= location:l assign_op:ao expr:e PUNTOYCOMA:pc {: RESULT = new AssignStmt(l,e,ao); :}
			| method_call:mc PUNTOYCOMA:pc {: RESULT = mc; :}
			| IF:i PARENTESIS_IZQUIERDO:pi expr:e PARENTESIS_DERECHO:pd statement:s {: RESULT = new IfStmt(e,s); :}
			| IF:i PARENTESIS_IZQUIERDO:pi expr:e PARENTESIS_DERECHO:pd statement:s1 ELSE:e statement:s2  {: RESULT = new IfStmt(e,s1,s2); :}
			| FOR:f ID:m IGUAL:i expr:e1 COMA:c expr:e2 statement:s {: RESULT = new ForStmt(m,e1,e2,s); :}
			| WHILE:w expr:e statement:s {: RESULT = new WhileStmt(e,s); :}
			| RETURN:r PUNTOYCOMA:pc {: RESULT = new ReturnStmt(); :}
			| RETURN:r expr:e PUNTOYCOMA:pc {: RESULT = new ReturnStmt(e); :}
			| BREAK:b PUNTOYCOMA:pc {: RESULT = new BreakStmt(); :}
			| CONTINUE:c PUNTOYCOMA:pc {: RESULT = new ContinueStmt(); :}
			| PUNTOYCOMA:pc {: RESULT = new PuntoYComaStmt(); :}
			| block:b {: RESULT = b :};
			
assign_op	::= ASIGNACION:a {: RESULT = AssignOpType.ASIGNACION; :}
			|ASIGNACION_SUMA:as {: RESULT = AssignOpType.ASIGNACION_SUMA; :}
			|ASIGNACION_RESTA:ar {: RESULT = AssignOpType.ASIGNACION_RESTA; :};
			
method_call ::= ID:m PARENTESIS_IZQUIERDO:pi expr_list:expl PARENTESIS_DERECHO:pd {: RESULT = new MethodCallStmt(m,expl); :}
			| ID:m method_list:ml PARENTESIS_IZQUIERDO:pi expr_list:expl PARENTESIS_DERECHO:pd /*completar*/
			;
			
expr_list ::= COMA:c expr:e expr_list:expl {: expl.add(e); RESULT = expl; :}
			| /* empty  */  {: RESULT = new LinkedList<Expression>(); :};
			
method_list	::= PUNTO:p ID:m method_list:ml
			| PUNTO:p ID:m method_call:mc method_list:ml
			| /* empty */  {: RESULT = new LinkedList<Expression>(); :}
			;
			
location	::= ID:m  {: RESULT = new Location(m); :}
			| ID:m CORCHETE_IZQUIERDO:ci expr:e CORCHETE_DERECHO:cd {: RESULT = new Location(m,e); :}
			| ID:m id_list:il
			| ID:m id_list:il CORCHETE_IZQUIERDO:ci expr:e CORCHETE_DERECHO:cd
			;
			
id_list		::= PUNTO:p ID:m id_list
			| /* empty */
			;

expr		::= location:l
			|method_call:mc
			|literal:l {: RESULT = l.getType(); :}
			|expr:e1 bin_op:bo expr:e2 {: RESULT = new BinOpExpression(e1,bo,e2); :}
			|RESTA expr:e {: RESULT = new UnaryOpExpression(UnaryOpType.RESTA,e); :}
			|NEGACION expr:e {: RESULT = new UnaryOpExpression(UnaryOpType.NEGACION,e); :}
			|PARENTESIS_IZQUIERDO:pi expr:e PARENTESIS_DERECHO:pd
			;
			
bin_op		::= arith_op:ao  {: RESULT = ao; :}
			|rel_op:ro {: RESULT = ro; :}
			|eq_op:eo	{: RESULT = eo; :}
			|cond_op:co {: RESULT = co; :};
			
arith_op	::= SUMA:s {: RESULT = BinOpType.SUMA; :}
			| RESTA:r {: RESULT = BinOpType.RESTA; :}
			| MULTIPLICACION:m {: RESULT = BinOpType.MULTIPLICACION; :}
			| DIVISION:d {: RESULT = BinOpType.DIVISION; :}
			| PORCENTAJE:p {: RESULT = BinOpType.PORCENTAJE; :};
			
rel_op		::= MENOR:me {: RESULT = BinOpType.MENOR; :}
			| MAYOR:ma {: RESULT = BinOpType.MAYOR; :}
			| MENOR_IGUAL:mei {: RESULT = BinOpType.MENOR_IGUAL; :}
			| MAYOR_IGUAL:mai {: RESULT = BinOpType.MAYOR_IGUAL; :};
			
eq_op		::= IGUAL:i {: RESULT = BinOpType.IGUAL; :}
			|DESIGUAL:d {: RESULT = BinOpType.DESIGUAL; :};
			
cond_op		::= CONJUNCION: c {: RESULT = BinOpType.CONJUNCION; :}
			| DISYUNCION: d {: RESULT = BinOpType.DISYUNCION; :};
			
literal		::= INTEGER_LITERAL:i {: RESULT = new Integer(i); :}
			|FLOAT_LITERAL:f {: RESULT = new Float(f); :}
			|TRUE_LITERAL: t {: RESULT = new Boolean(true); :}
			|FALSE_LITERAL:f {: RESULT = new Boolean(false); :};